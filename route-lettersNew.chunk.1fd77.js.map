{"version":3,"sources":["webpack:///./routes/lettersNew/style.css","webpack:///../src/index.js","webpack:///./routes/lettersNew/index.js"],"names":["module","exports","getHookState","index","type","options","_hook","currentComponent","currentHook","hooks","__hooks","_list","_pendingEffects","length","push","useState","initialState","reducer","init","hookState","currentIndex","_component","_value","invokeOrReturn","nextValue","action","setState","useReducer","useEffect","callback","args","state","_skipEffects","argsChanged","_args","flushAfterPaintEffects","afterPaintEffects","some","component","_parentDom","forEach","invokeCleanup","invokeEffect","e","_catchError","_vnode","hook","_cleanup","result","oldArgs","newArgs","arg","f","prevRaf","oldBeforeRender","_render","oldAfterDiff","diffed","oldCommit","_commit","oldBeforeUnmount","unmount","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","cancelAnimationFrame","setTimeout","window","commitQueue","_renderCallbacks","filter","cb","BetterLetters","letters","setLetters","letterCount","setLetterCount","seconds","setSeconds","playMode","setPlayMode","secondsDegrees","setSecondsDegrees","setComputerChoicesOpen","enteredText","setEnteredText","setWordMisMatch","definitions","setDefinitions","wordCheckEmployed","timer","setTimer","setComputerAnagrams","console","log","setInterval","clearInterval","class","style","profile","innerContainer","instructionContainer","instructionText","instructionTextOff","buttonContainer","button","buttonOff","onClick","vowelsArray","total","i","threshold","Math","floor","random","consonantsArray","letterContainer","letterDiv","startGame","letterArray","letterString","join","axios","get","headers","then","response","data","catch","error","getComputerAnagrams","Audio","play","playAgainContainer","clock","clockOff","clockFace","position","top","left","transformOrigin","transform","background","height","width","form","formOff","name","onSubmit","preventDefault","wordToCheck","event","target","value","column","answer","id","wordContainer","map","definition"],"mappings":"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","file":"route-lettersNew.chunk.1fd77.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"profile\":\"profile__1XJ0x\",\"innerContainer\":\"innerContainer__2fZVg\",\"instructionContainer\":\"instructionContainer__1Cwdr\",\"instructionText\":\"instructionText__1XPFV\",\"instructionTextOff\":\"instructionTextOff__1f9X3\",\"buttonContainer\":\"buttonContainer__2yV2x\",\"letterContainer\":\"letterContainer__xud11\",\"letterDiv\":\"letterDiv__rY_Tq\",\"button\":\"button__2TV-F\",\"buttonOff\":\"buttonOff__65j0E\",\"clock\":\"clock__aCJ8v\",\"clockOff\":\"clockOff__2Bj-E\",\"clock-face\":\"clock-face__2Cr_I\",\"startGame\":\"startGame__3y7Zh\",\"form\":\"form__27b2C\",\"column\":\"column__k-YLZ\",\"formOff\":\"formOff__1IcIP\",\"answer\":\"answer__2dZUV\",\"computerChoices\":\"computerChoices__2dwCG\",\"computerChoicesOff\":\"computerChoicesOff__2d6d6\",\"computerChoicesShown\":\"computerChoicesShown__2hmPY\",\"computerChoicesHidden\":\"computerChoicesHidden__na8Xb\",\"listContainer\":\"listContainer__Nhsyw\",\"listContainerOff\":\"listContainerOff__1-W-2\",\"wordContainer\":\"wordContainer__3Q9QN\",\"playAgainContainer\":\"playAgainContainer__3-asJ\"};","import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tif (currentComponent.__hooks) {\n\t\tcurrentComponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\tcurrentComponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\tcurrentComponent.__hooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (!c) return;\n\n\tconst hooks = c.__hooks;\n\tif (hooks) {\n\t\tif (hooks._pendingEffects.length) {\n\t\t\tafterPaint(afterPaintEffects.push(c));\n\t\t}\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (!c) return;\n\n\tconst hooks = c.__hooks;\n\tif (hooks) {\n\t\ttry {\n\t\t\thooks._list.forEach(hook => hook._cleanup && hook._cleanup());\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value[0] = nextValue;\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tcancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (typeof window != 'undefined') {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (hook._cleanup) hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\tconst result = hook._value();\n\tif (typeof result == 'function') hook._cleanup = result;\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n","import { h, Component } from 'preact';\nimport { useState, useEffect } from \"preact/hooks\";\nimport style from './style';\n// import { getCurrentUrl } from 'preact-router';\nimport axios from 'axios';\n\nconst BetterLetters = () => {\n    const [letters, setLetters] = useState([]);\n    const [letterCount, setLetterCount] = useState(0);\n    let [seconds, setSeconds] = useState(30);\n    const [playMode, setPlayMode] = useState('choosingLetters'); // choosingLetters, ready, finished\n    let [secondsDegrees, setSecondsDegrees] = useState(90);\n    const [computerChoicesOpen, setComputerChoicesOpen] = useState(false);\n    const [enteredText, setEnteredText] = useState('');\n    const [wordMisMatch, setWordMisMatch] = useState(false);\n    const [definitions, setDefinitions] = useState([]);\n    const [wordCheckEmployed, setWordCheckEmployed] = useState(false);\n    const [timer, setTimer] = useState(0);\n    // const [count, setCount] = useState(10);\n    const [computerAnagrams, setComputerAnagrams] = useState([])\n\n    function getVowel () {\n      const vowelsArray = [\n        [\"A\", 15],\n        [\"E\", 21],\n        [\"I\", 13],\n        [\"O\", 13],\n        [\"U\", 5],\n      ];\n  \n      // Get the total weight\n      let total = 1;\n      for (let i = 0; i < vowelsArray.length; ++i) {\n        total += vowelsArray[i][1];\n      }\n  \n      console.log({ total });\n  \n      // Get random index\n      const threshold = Math.floor(Math.random() * total);\n  \n      console.log({ threshold });\n  \n      // Find value that meets threshold\n      total = 0;\n      for (let i = 0; i < vowelsArray.length; ++i) {\n        // Add the weight to our running total.\n        total += vowelsArray[i][1];\n  \n        // If this value falls within the threshold, we're done!\n        if (total >= threshold) {\n          const randomVowel = vowelsArray[i][0];\n          setLetters([...letters, randomVowel]);\n          setLetterCount(letterCount + 1);\n          break;\n        }\n      }\n    }\n\n    function getConsonant () {\n      const consonantsArray = [\n        [\"B\", 2],\n        [\"C\", 3],\n        [\"D\", 6],\n        [\"F\", 2],\n        [\"G\", 3],\n        [\"H\", 2],\n        [\"J\", 1],\n        [\"K\", 1],\n        [\"L\", 5],\n        [\"M\", 4],\n        [\"N\", 8],\n        [\"P\", 4],\n        [\"Q\", 1],\n        [\"R\", 9],\n        [\"S\", 9],\n        [\"T\", 9],\n        [\"V\", 1],\n        [\"W\", 1],\n        [\"X\", 1],\n        [\"Y\", 1],\n        [\"Z\", 1],\n      ];\n  \n      // Get the total weight\n      let total = 1;\n      for (let i = 0; i < consonantsArray.length; ++i) {\n        total += consonantsArray[i][1];\n      }\n  \n      console.log({ total });\n  \n      // Get random index\n      const threshold = Math.floor(Math.random() * total);\n  \n      // Find value that meets threshold\n      total = 0;\n      for (let i = 0; i < consonantsArray.length; ++i) {\n        // Add the weight to our running total.\n        total += consonantsArray[i][1];\n  \n        // If this value falls within the threshold, we're done!\n        if (total >= threshold) {\n          const randomConsonant = consonantsArray[i][0];\n          setLetters([...letters, randomConsonant]);\n          setLetterCount(letterCount + 1);\n          break;\n        }\n      }\n    }\n\n    useEffect(() => {\n      'Is this being called every time?'\n      if (letterCount === 9) {\n        console.log({letterCount});\n        setPlayMode('ready');\n        setSeconds(30);\n      }\n    }, [letters, letterCount])\n\n    function startPlayback() {\n      const audioPromise = new Audio(\"../../assets/audio/countdown.mp3\").play();\n      return audioPromise;\n    }\n\n    function startTimer() {\n      // fetch best responses from CountDown API\n      getComputerAnagrams(letters);\n  \n      console.log(seconds);\n      if (seconds && seconds > 0) {\n        console.log(\"Attempting to play automatically...\");\n  \n        startPlayback()\n          .then(() => {\n            console.log(\"The play() Promise fulfilled! Rock on!\");\n          })\n          .catch((error) => {\n            console.log(error);\n          });\n      }\n    }\n\n    useEffect(setTimer(setInterval(() => {\n        setSeconds(seconds -= 1);\n        setSecondsDegrees(secondsDegrees += (360/60));\n        if (seconds === 0) {\n          console.log('is this check happening??')\n          clearInterval(timer);\n          setPlayMode('finished');\n        }\n      }, 1000)), [seconds, secondsDegrees]);\n\n    // function countDown() {\n    //   // Remove one second, set state so a re-render happens.\n    //   console.log(\"counting down the seconds ...\");\n  \n    //   // let countSeconds = seconds - 1;\n    //   // let secondsDegrees = secondsDegrees + 360 / 60;\n    //   setSeconds(seconds -= 1);\n    //   setSecondsDegrees(secondsDegrees += (360/60));\n\n  \n    //   // Check if we're at zero.\n    //   if (seconds === 0) {\n    //     console.log('is this check happening??')\n    //     clearInterval(timer);\n    //     setPlayMode('finished');\n    //   }\n    // }\n\n    function getComputerAnagrams(letterArray) {\n      console.log(letterArray);\n      const letterString = letterArray.join(\"\");\n      console.log({ letterString });\n  \n      axios\n        .get(\n          `https://danielthepope-countdown-v1.p.rapidapi.com/solve/${letterString}?variance=1`,\n          {\n            headers: {\n              \"x-rapidapi-host\": \"danielthepope-countdown-v1.p.rapidapi.com\",\n              \"x-rapidapi-key\":\n                \"5e458fcdc9msheb1cb44d935da2fp1cbb49jsnd1ef623fd51c\",\n            },\n          }\n        )\n        .then((response) => {\n          console.log(response.data);\n          setComputerAnagrams(response.data);\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n\n    function checkWord(e) {\n      e.preventDefault();\n      const wordToCheck = event.target['inputWord'].value\n      \n      // if(wordToCheck.split('').every(letter => this.state.letters.includes(letter))) {\n        let config = {\n          headers: {\n            \"x-rapidapi-host\": \"wordsapiv1.p.rapidapi.com\",\n            \"x-rapidapi-key\": \"5e458fcdc9msheb1cb44d935da2fp1cbb49jsnd1ef623fd51c\"\n          }\n        }\n    \n        axios.get(`https://wordsapiv1.p.rapidapi.com/words/${wordToCheck}/definitions/`\n        , config)\n        .then((response) => {\n          console.log(response.data);\n          \n            setDefinitions(response.data['definitions']);\n            setWordMisMatch(true);\n        })\n        .catch((error)=> {\n          console.log(error);\n        });\n  \n      // } else {\n      //   this.setState({wordMisMatch: true,})\n      // }\n  \n      \n    }\n  \n    function showComputerChoices() {\n      setComputerChoicesOpen(true);\n    }\n  \n    function clearInput() {\n      if(wordMisMatch) {\n        setEnteredText('');\n        setWordMisMatch(false);\n      }\n    }\n  \n    function playAgain() {\n        setPlayMode('choosingLetters');\n        setLetterCount(0);\n        setLetters([]);\n        setComputerChoicesOpen(false);\n        setSecondsDegrees(90);\n        setEnteredText('');\n        setWordMisMatch(false);\n        setDefinitions([]);\n    }\n  \n  \n    console.log(playMode);\n    console.log(secondsDegrees);\n    return (\n      \n      <div class={style.profile}>\n        <div class={style.innerContainer}>\n        <div class={style.instructionContainer}>\n          <p\n            class={\n              playMode === \"choosingLetters\"\n                ? style.instructionText\n                : style.instructionTextOff\n            }\n          >\n            Choose a letter\n          </p>\n        </div>\n\n        <div class={style.buttonContainer}>\n          <button\n            class={\n              playMode !== \"finished\" ? style.button : style.buttonOff\n            }\n            onClick={getVowel}\n          >\n            Vowel\n          </button>\n          <button\n            class={\n              playMode !== \"finished\" ? style.button : style.buttonOff\n            }\n            onClick={getConsonant}\n          >\n            Consonant\n          </button>\n        </div>\n\n        <div class={style.letterContainer}>\n          <div class={style.letterDiv}>\n            {letters[0] ? letters[0] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[1] ? letters[1] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[2] ? letters[2] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[3] ? letters[3] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[4] ? letters[4] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[5] ? letters[5] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[6] ? letters[6] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[7] ? letters[7] : \"?\"}\n          </div>\n          <div class={style.letterDiv}>\n            {letters[8] ? letters[8] : \"?\"}\n          </div>\n        </div>\n\n        <div class={style.startGame}>\n          <button\n            class={\n              playMode === \"ready\" ? style.button : style.buttonOff\n            }\n            onClick={startTimer}\n          >\n            Start Countdown\n          </button>\n        </div>\n\n        <div class={style.playAgainContainer}>\n          <button\n            class={\n              playMode === \"finished\" ? style.button : style.buttonOff\n            }\n            onClick={playAgain}\n          >\n            Play again\n          </button>\n        </div>\n\n        <div class={playMode !== \"finished\" ? style.clock : style.clockOff}>\n          <div class={style.clockFace}>\n            <div\n              style={{\n                position: \"absolute\",\n                top: \"50%\",\n                left: \"0%\",\n                transformOrigin: \"100%\",\n                transform: `rotate(${secondsDegrees}deg)`,\n                background: \"aqua\",\n                height: \"4px\",\n                width: \"50%\",\n              }}\n            />\n          </div>\n        </div>\n\n        <form class={playMode === \"finished\" ? style.form: style.formOff} name=\"wordToCheck\" onSubmit={checkWord}>\n          <div class={style.column}>\n            <input class={style.answer} id=\"wordToCheck\" name=\"inputWord\" type=\"text\" value={enteredText} />\n\n            <input type=\"Submit\" class={style.button} value=\"Check word in dictionary\" />\n          </div>\n            <div class={style.wordContainer}>\n            {wordCheckEmployed && definitions.length === 0\n              ? \"❌ Word not found in dictionary\"\n              : <div>\n              <span>{definitions.length > 0 ? \"✅ Word found! Definition(s):\" : \"\"}</span>\n              <ul> {definitions.map((result) => (\n                \n                    <li>{result.definition}</li>\n                  \n                ))}\n                </ul></div>}\n                \n            </div>\n        </form>\n\n  \n        {/* <div class={playMode === \"finished\" ? style.listContainer: style.listContainerOff}>\n          <div class={playMode === \"finished\" ? style.computerChoices: style.computerChoicesOff}>\n            {!computerAnagrams\n              ? \"\"\n              : `The computer found ${computerAnagrams.length} word(s). Longest word has ${computerAnagrams[0]['length']} characters.  `}\n              <a href=\"#\" class={playMode === \"finished\" ? style.link : style.linkOff} onClick={showComputerChoices}>  Click here</a> to view word(s):\n              \n              <ul class={computerChoicesOpen ? style.computerChoicesShown : style.computerChoicesHidden}>\n                {!computerAnagrams\n                  ? \"\"\n                  : computerAnagrams.map((result) => (\n                  <li>{result.word} - length {result.length}</li>\n                    ))}\n              </ul>\n            </div>\n        </div> */}\n        \n      </div>\n    </div>\n\n  );\n\n\n}\n\n\n  export default BetterLetters"],"sourceRoot":""}